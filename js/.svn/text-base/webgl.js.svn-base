/*
 * Demo html5 3d Player
 * 
 * Author 	: Hong.Yao
 * Email	: yhong@iscope.de
 * 
 */

/*
 * necessary libraries
 * glUtils.js
 * sylvester.js 
 */

/*
 * 
 References
 [W]WebGL Specification : http://www.khronos.org/registry/webgl/specs/latest/
 [C]HTML Canvas 2D Context : http://dev.w3.org/html5/2dcontext/
 [S]OpenGL ES Specification : http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf
 [M]General Matrix Operations : http://code.google.com/p/glmatrix/wiki/Usage
 [P]Perspective projection : http://en.wikipedia.org/wiki/Transformation_matrix#Perspective_projection
 [SYL] http://sylvester.jcoglan.com/docs.html
 [WS6] WebGL Study 6 : http://learningwebgl.com/blog/?p=571
 [WS5] WebGL Stydy 5 : http://learningwebgl.com/blog/?p=507
 [NP] The differences between WebGl and OpenGl :
 		http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support.
 *
 */

/** global variables **/
// video
var videoElement;
// canvas
var canvasElement;
// if show the informations of debug in console 
var debugFlag 				= true;
// how to show the message of error: 1 - console , 0 - alert
var errorHandlerType 		= 1;
// how to show the message of debug: 1 - console , 0 - alert
var debugHandlerType 		= 1;
// the path to js folder
var path2Shader 			= "js/";
// the name of fragment shader file
var leftFragmentShaderFile 	= "fragment-left.shader";
var rightFragmentShaderFile = "fragment-right.shader";
var SBSFragmentShaderFile 	= "fragment-ori.shader";

var currentLeftFragmentShaderFile = leftFragmentShaderFile;
var currentRightFragmentShaderFile = rightFragmentShaderFile;

// the name of vertex shader file
var vertexShaderFile 		= "vertex.shader";
// shader program
var leftShaderProgram;
var rightShaderProgram;
// WebGL object
var gl;


/** data buffer **/
// scene
// left part of the video
var leftSceneTexture;
var leftSceneVerticesBuffer;
var leftSceneVerticesTextureCoordBuffer;
var leftSceneVerticesIndexBuffer;
var leftSceneVerticesNormalBuffer;
// right part of the video
var rightSceneTexture;
var rightSceneVerticesBuffer;
var rightSceneVerticesTextureCoordBuffer;
var rightSceneVerticesIndexBuffer;
var rightSceneVerticesNormalBuffer;
// global buffer for the left part of the scene
var leftVertexPositionAttribute;
var leftTextureCoordAttribute;
//global buffer for the right part of the scene
var rightVertexPositionAttribute;
var rightTextureCoordAttribute;
// matrix data
var mvMatrix;
var mvMatrixStack = [];
var perspectiveMatrix;

//effect
var effector;
var showChannel = 2;
var sceneVertices = [
	-1.0,  -1.0,  0.0,
	1.0,  -1.0,  0.0,
	1.0, 1.0,  0.0,
	-1.0, 1.0,  0.0
];

//Map the texture
var leftSceneTextureCoordinates;
if(showChannel == 2){
	leftSceneTextureCoordinates = [
		0.0,  0.0,
		0.5,  0.0,
		0.5,  1.0,
		0.0,  1.0
	 ];
}
else{
	leftSceneTextureCoordinates = [
   		0.0,  0.0,
   		1.0,  0.0,
   		1.0,  1.0,
   		0.0,  1.0
   	 ];
}
var rightSceneTextureCoordinates = [
	0.5,  0.0,
	1.0,  0.0,
	1.0,  1.0,
	0.5,  1.0
];

// start webgl
function webGLStart(){
	try{
	    // Initialize the WebGL environment
		canvasElement 			= document.getElementById("c");
		videoElement 			= document.getElementById('video');
		//canvasElement.width 	= videoElement.width;
		//canvasElement.height 	= videoElement.height;
		
		effector				= document.getElementById("effect");
		
	    initWebGL(canvasElement);    
	    // iIitialize the shader
	    initShaders();    
	    // Initialize the buffer
	    initBuffers();    
	    // If the WebGL usable
	    initTexture();
	    
	    if(gl){
	    	// See [W]2.1
	    	// Set clear color to black, fully opaque
	    	gl.clearColor(0.0, 0.0, 0.0, 1.0);
	    	// Clear everything
	        gl.clearDepth(1.0);
	     	// Enable depth testing, to ensure the Hide. If you want to have the blend Effect,
	        // depth testing mast be shut down
	    	//gl.enable(gl.DEPTH_TEST);
	        gl.disable(gl.DEPTH_TEST);
	        gl.enable(gl.BLEND);
	        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);	        
	    	// Near things obscure far things
	        gl.depthFunc(gl.LEQUAL);
	    	// Clear the buffers of color and depth
	        gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
	    	// Get Information of the context, see [W]5.14.2
	    }
	    else{
	    	throw("Unable to initialize WebGL. Your browser may not support it.");
	    }
	}
    catch(e){
		errorHandler(errorHandlerType, arguments.callee.name, e);
	}
}

function effectChange() {
	var effect = effector.options[effector.selectedIndex].value;	
	if(effect == 'cm' || !effect){
		showChannel = 2;
		leftSceneTextureCoordinates = [
       		0.0,  0.0,
       		0.5,  0.0,
       		0.5,  1.0,
       		0.0,  1.0
       	];
		currentLeftFragmentShaderFile = leftFragmentShaderFile;
		currentRightFragmentShaderFile = rightFragmentShaderFile;
	}
	else if(effect == 'sbs' || effect == 'orgi'){
		showChannel = 1;
		leftSceneTextureCoordinates = [
      		0.0,  0.0,
      		1.0,  0.0,
      		1.0,  1.0,
      		0.0,  1.0
      	 ];		
		currentLeftFragmentShaderFile = SBSFragmentShaderFile;
		currentRightFragmentShaderFile = SBSFragmentShaderFile;
	}
	if(leftSceneVerticesTextureCoordBuffer){
		gl.bindBuffer(gl.ARRAY_BUFFER, leftSceneVerticesTextureCoordBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(leftSceneTextureCoordinates), gl.STATIC_DRAW);
	}
	initShaders();
	
}

// initial of the texture
function initTexture() {
	try{
		// create the texture for scene
		leftSceneTexture 	= gl.createTexture();
		rightSceneTexture 	= gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, leftSceneTexture);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);		
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(gl.TEXTURE_2D, null);
		gl.bindTexture(gl.TEXTURE_2D, rightSceneTexture);
		gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);		
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
	catch(e){
		errorHandler(errorHandlerType, arguments.callee.name, e);
	}
}



// update the content of the texture
function updateTexture(){
	try{
		// left part of the scene
		gl.bindTexture(gl.TEXTURE_2D, leftSceneTexture);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoElement);		
		gl.bindTexture(gl.TEXTURE_2D, null);
		// right part of the scene
		gl.bindTexture(gl.TEXTURE_2D, rightSceneTexture);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, videoElement);
		gl.bindTexture(gl.TEXTURE_2D, null);
	}
	catch(e){
		errorHandler(errorHandlerType, arguments.callee.name, e);
	}
}

//
//	initWebGL
//	Initialize WebGL, returning the GL context or null if 
//	WebGL isn't available or could not be initialized. 
//
function initWebGL(canvas){
	gl = null;
	try{
		// See [W]5.2.1
		gl 					= canvas.getContext("experimental-webgl");
		gl.viewportWidth 	= canvas.width;
        gl.viewportHeight 	= canvas.height;
		if(!gl){
			throw("Unable to initialize WebGL. Your browser may not support it.");
		}
	}
	catch(e){
		errorHandler(errorHandlerType, arguments.callee.name, e);
	}	
}

//
//initShaders
//
//Initialize the shaders, so WebGL knows how to light our scene.
//
function initShaders(){
	try{
		var leftFragmentShader = getShader(gl,currentLeftFragmentShaderFile);
		var rightFragmentShader = getShader(gl,currentRightFragmentShaderFile);
		var vertexShader 		= getShader(gl, vertexShaderFile);
		// create the left shader program
		leftShaderProgram 		= gl.createProgram();		
		gl.attachShader(leftShaderProgram, vertexShader);
		gl.attachShader(leftShaderProgram, leftFragmentShader);
		gl.linkProgram(leftShaderProgram);		
		// If creating the shader program failed, alert
		if (!gl.getProgramParameter(leftShaderProgram, gl.LINK_STATUS)){
	    	throw("Unable to initialize the left shader program.");
	    }
		// configuration of the shader program for the left part of the scene
		leftVertexPositionAttribute 		= gl.getAttribLocation(leftShaderProgram, "aVertexPosition");
		gl.enableVertexAttribArray(leftVertexPositionAttribute);
		leftTextureCoordAttribute 			= gl.getAttribLocation(leftShaderProgram, "aTextureCoord");
		gl.enableVertexAttribArray(leftTextureCoordAttribute);		
		leftShaderProgram.pMatrixUniform 	= gl.getUniformLocation(leftShaderProgram, "uPMatrix");
        leftShaderProgram.mvMatrixUniform 	= gl.getUniformLocation(leftShaderProgram, "uMVMatrix");
        leftShaderProgram.samplerUniform 	= gl.getUniformLocation(leftShaderProgram, "uSampler");
        // create the right shader program
        rightShaderProgram = gl.createProgram();
		gl.attachShader(rightShaderProgram, vertexShader);
		gl.attachShader(rightShaderProgram, rightFragmentShader);
		gl.linkProgram(rightShaderProgram);		
		// If creating the shader program failed, alert
		if (!gl.getProgramParameter(rightShaderProgram, gl.LINK_STATUS)){
	    	throw("Unable to initialize the right shader program.");
	    }        
        // configuration of the shader program for the right part of the scene
		rightVertexPositionAttribute 		= gl.getAttribLocation(rightShaderProgram, "aVertexPosition");
		gl.enableVertexAttribArray(rightVertexPositionAttribute);
		rightTextureCoordAttribute 			= gl.getAttribLocation(rightShaderProgram, "aTextureCoord");
		gl.enableVertexAttribArray(rightTextureCoordAttribute);		
		rightShaderProgram.pMatrixUniform 	= gl.getUniformLocation(rightShaderProgram, "uPMatrix");
        rightShaderProgram.mvMatrixUniform 	= gl.getUniformLocation(rightShaderProgram, "uMVMatrix");
        rightShaderProgram.samplerUniform 	= gl.getUniformLocation(rightShaderProgram, "uSampler");
	}
	catch(e){
		errorHandler(errorHandlerType, arguments.callee.name, e);
	}
}

//
//getShader
//
//Loads a shader program by scouring the current document,
//looking for a script with the specified ID.
//
function getShader(gl, id){
	try{
		var _theSource = a(path2Shader+id, {}, "post", false, false);				
		// Didn't find an element with the specified ID; abort.
		if(!_theSource){
			return null;
		}
		// Now figure out what type of shader script we have,
		// based on its MIME type.
		var _shader;
		if(id == leftFragmentShaderFile || id == rightFragmentShaderFile || id == SBSFragmentShaderFile){
			_shader = gl.createShader(gl.FRAGMENT_SHADER);
		}
		else if(id == vertexShaderFile){
			_shader = gl.createShader(gl.VERTEX_SHADER);
		}
		else {
			// Unknown shader type
			return null;  
		}
		// Send the source to the shader object
		// See [W]5.14.9 and [S]2.10.1
		gl.shaderSource(_shader, _theSource);
		// Compile the shader program
		gl.compileShader(_shader);
		// See if it compiled successfully
		if (!gl.getShaderParameter(_shader, gl.COMPILE_STATUS)) {
		    debug("An error occurred compiling the shaders: " + gl.getShaderInfoLog(_shader));
		    return null;
		}  
		return _shader;
	}
	catch(e){
		errorHandler(errorHandlerType, arguments.callee.name, e);
	}
}

//
// changeBuffers
//
// modify the buffers when necessary
//



//
//initBuffers
//
//Initialize the buffers we'll need.
//
function initBuffers(){
	try{
		// Create a buffer for the vertices
		leftSceneVerticesBuffer 	= gl.createBuffer(); 
		rightSceneVerticesBuffer 	= gl.createBuffer();
		// Select the verticesBuffer as the one to apply vertex
		// operations to from here out
		// Now create an array of vertices, the element of the array is according to the 
		//coordinate of the four vertexes point in the 3-dimension-space
		// Now pass the list of vertices into WebGL to build the shape. We
		// do this by creating a Float32Array from the JavaScript array,
		// then use it to fill the current vertex buffer.
		gl.bindBuffer(gl.ARRAY_BUFFER, leftSceneVerticesBuffer);		
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sceneVertices), gl.STATIC_DRAW);
		gl.bindBuffer(gl.ARRAY_BUFFER, rightSceneVerticesBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sceneVertices), gl.STATIC_DRAW);
		
		leftSceneVerticesTextureCoordBuffer 	= gl.createBuffer();
		rightSceneVerticesTextureCoordBuffer 	= gl.createBuffer();
		//left part of the video		
		gl.bindBuffer(gl.ARRAY_BUFFER, leftSceneVerticesTextureCoordBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(leftSceneTextureCoordinates), gl.STATIC_DRAW);
		 //right part of the video		
		gl.bindBuffer(gl.ARRAY_BUFFER, rightSceneVerticesTextureCoordBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(rightSceneTextureCoordinates), gl.STATIC_DRAW);
		// into the vertex array for each face's vertices.
		leftSceneVerticesIndexBuffer = gl.createBuffer();
		rightSceneVerticesIndexBuffer = gl.createBuffer();		
		// This array defines each face as two triangles, using the
		// indices into the vertex array to specify each triangle's
		// position.
		var sceneVertexIndices = [
			0,  1,  2,      0,  2,  3                      
		];
		// Now send the element array to GL
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, leftSceneVerticesIndexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sceneVertexIndices), gl.STATIC_DRAW);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, rightSceneVerticesIndexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sceneVertexIndices), gl.STATIC_DRAW);
	}
	catch(e){
		errorHandler(errorHandlerType, arguments.callee.name, e);
	}
}

//
//drawScene
//
//Draw the scene.
//
function drawScene(){
	try{
		updateTexture();
		// Clear the canvas before we start drawing on it.
		gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
		// Clear the canvas before we start drawing on it.
		gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		// Establish the perspective with which we want to view the
		// scene. Our field of view is 45 degrees, with a width/height
		// ratio of 1:1, and we only want to see objects between 0.1 units
		// and 100 units away from the camera.
		perspectiveMatrix = makePerspective(90, 1, 0.1, 100.0);
		// Set the drawing position to the "identity" point, which is
		// the center of the scene.
		loadIdentity();
		// Now move the drawing position a bit to where we want to start
		mvTranslate([0.0, 0.0, -1.0]);
		
		// Draw by binding the array buffer to the vertices
		// left part
		gl.useProgram(leftShaderProgram);
		gl.bindBuffer(gl.ARRAY_BUFFER, leftSceneVerticesBuffer);
		gl.vertexAttribPointer(leftVertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
		// Set the texture coordinates attribute for the vertices.
		gl.bindBuffer(gl.ARRAY_BUFFER, leftSceneVerticesTextureCoordBuffer);
		gl.vertexAttribPointer(leftTextureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
		// Specify the texture to map onto the faces.
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, leftSceneTexture);
		gl.uniform1i(leftShaderProgram.samplerUniform, 0);
		// Draw Buffer , see [W]2.2 , [W]5.14.11
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, leftSceneVerticesIndexBuffer);
		setMatrixUniforms(leftShaderProgram);
		gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
		if(showChannel == 2){
			// right part		
			gl.useProgram(rightShaderProgram);
			gl.bindBuffer(gl.ARRAY_BUFFER, rightSceneVerticesBuffer);
			gl.vertexAttribPointer(rightVertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
			gl.bindBuffer(gl.ARRAY_BUFFER, rightSceneVerticesTextureCoordBuffer);
			gl.vertexAttribPointer(rightTextureCoordAttribute, 2, gl.FLOAT, false, 0, 0);
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, rightSceneTexture);
			gl.uniform1i(rightShaderProgram.samplerUniform, 0);
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, leftSceneVerticesIndexBuffer);
			setMatrixUniforms(rightShaderProgram);
			gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);		
		}
	}
	catch(e){
		errorHandler(errorHandlerType, arguments.callee.name, e);
	}
}

//
//Matrix utility functions
//
function loadIdentity() {
	mvMatrix = Matrix.I(4);
}

function multMatrix(m) {
	mvMatrix = mvMatrix.x(m);
}

function mvTranslate(v) {
	multMatrix(Matrix.Translation($V([v[0], v[1], v[2]])).ensure4x4());
}

function setMatrixUniforms(program) {
	try{
		// See [S]2.10
	    gl.uniformMatrix4fv(program.pMatrixUniform, false, new Float32Array(perspectiveMatrix.flatten()));
	    gl.uniformMatrix4fv(program.mvMatrixUniform, false, new Float32Array(mvMatrix.flatten()));
	    var normalMatrix = mvMatrix.inverse();
	    normalMatrix = normalMatrix.transpose();
	    gl.uniformMatrix4fv(program.normalMatrixUniform, false, new Float32Array(normalMatrix.flatten()));
	}
    catch(e){
		errorHandler(errorHandlerType, arguments.callee.name, e);
	}
}